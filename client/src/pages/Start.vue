<template>
  <div class="main">
    <div class="rpc-availability">
      <h4>Enter RPC port</h4>
      <input
        type="number"
        v-model="rpcPort"
        placeholder="Enter rpc port"
        @input="checkAvailable()"
      />
      <div v-if="rpcPort" class="port-info">
        <p v-if="rpcAvailable">
          port <b>{{ rpcPort }}</b> is available!
        </p>
        <p v-else>
          port <b>{{ rpcPort }}</b> is <i>not</i> available
        </p>
      </div>
    </div>
    <div class="fileInput">
      <form id="contract-form" v-on:submit="compile()">
        <input
          type="file"
          id="contract"
          ref="contractFile"
          v-on:change="handleFile()"
          class="inputfile btn"
        />
        <label v-if="contractFile" for="contract">{{
          contractFile.name
        }}</label>
        <label v-else for="contract">Choose .sol file</label>
        <input type="checkbox" id="deployed" v-model="checked" />
        <label for="deployed">Contract already active</label>
        <input
          v-if="checked"
          type="text"
          id="contractAddress"
          placeholder="Contract Address"
          v-model="contractAddress"
        />
        <input type="submit" value="Submit" class="btn" />
      </form>
    </div>
    <div v-if="contractAddress" class="compilation-wrapper">
      <p>Smart Contract deployed at: {{ contractAddress }}</p>
      <div v-if="resContracts" class="functions-wrapper">
        <div
          class="files"
          v-for="(filename, idx_0) in resContracts"
          :key="idx_0"
        >
          <div
            class="contract"
            v-for="(contract, idx_1) in Object.keys(filename)"
            :key="idx_1"
          >
            <h2>{{ contract }}</h2>
            <div
              class="function"
              v-for="(func, idx_2) in filename[contract].abi"
              :key="idx_2"
            >
              <form
                v-if="func.type === 'function'"
                :id="func.name"
                @submit.prevent="
                  execute(
                    contract,
                    funcInput[func.name],
                    funcData[func.name].types,
                    func.name,
                    contractAddress,
                    rpcPort
                  )
                "
              >
                <input
                  type="text"
                  name="params"
                  :placeholder="funcData[func.name].placeholder"
                  v-model="funcInput[func.name]"
                />
                <input
                  type="submit"
                  name="functionName"
                  :value="func.name"
                  class="btn"
                />
              </form>
            </div>
          </div>
        </div>
        <p v-if="lastDuration">Execution time: {{ lastDuration }} ms</p>
      </div>
    </div>
  </div>
</template>

<script>
import axios from "axios";
export default {
  data() {
    return {
      network: window.location.hostname,
      rpcPort: "",
      apiEndpoints: [":3000/compile", ":3000/execute", ":3000/deploy"],
      rpcAvailable: false,
      contractFile: null,
      contractAddress: null,
      checked: false,
      resContracts: null,
      funcData: {},
      funcInput: {},
      funcOutput: {},
      lastDuration: null
    };
  },
  methods: {
    compile() {
      let self = this;
      const endpoint = `http://${this.network}${this.apiEndpoints[0]}`;
      let contractData = new FormData();
      contractData.append("contract", this.contractFile);
      axios
        .post(endpoint, contractData, {
          headers: {
            "Content-Type": "multipart/form-data"
          }
        })
        .then(function(res) {
          const resContracts = res.data.contracts;
          for (const filename of Object.keys(resContracts)) {
            for (const contract of Object.keys(resContracts[filename])) {
              const abi = resContracts[filename][contract].abi;
              const byteCode =
                resContracts[filename][contract].evm.bytecode.object;
              self.deploy(byteCode);
              for (const func of Object.keys(abi)) {
                if (abi[func].type === "function") {
                  let types = [];
                  let placeholder = [];
                  for (const input of abi[func].inputs) {
                    types.push(input.internalType);
                    placeholder.push(
                      [input.internalType, input.name].join(" ")
                    );
                  }
                  self.funcData[abi[func].name] = {
                    types: types,
                    placeholder: placeholder
                  };
                }
              }
            }
          }
          self.resContracts = resContracts;
        })
        .catch(function(err) {
          console.log(err);
        });
    },
    execute(contractName, input, types, name, address, port) {
      let self = this;
      const data = {
        input: input,
        types: types,
        name: name,
        address: address,
        port: port
      };
      const endpoint = `http://${this.network}${this.apiEndpoints[1]}`;
      axios
        .post(endpoint, data, {
          headers: {
            "Content-Type": "application/json"
          }
        })
        .then(function(res) {
          self.funcOutput[res.data.timestamp] = {
            contractName: contractName,
            functionName: name,
            rpcResponse: res.data.rpcResponse,
            duration: res.data.duration
          };
          self.lastDuration = res.data.duration;
        });
    },
    deploy(byteCode) {
      let self = this;
      const endpoint = `http://${this.network}${this.apiEndpoints[2]}`;
      axios
        .post(
          endpoint,
          {
            byteCode: byteCode,
            rpcPort: self.rpcPort
          },
          {
            headers: {
              "Content-Type": "application/json"
            }
          }
        )
        .then(function(res) {
          self.contractAddress = res.data;
        });
    },
    checkAvailable() {
      let self = this;
      const endpoint = `http://${this.network}:${this.rpcPort}`;
      if (this.rpcPort.length === 4) {
        axios
          .post(endpoint, {}, { timeout: 500 })
          .then(function(res) {
            if (res.status === 200) {
              self.rpcAvailable = true;
            }
          })
          .catch(function(err) {
            if (err.code === "ECONNABORTED") {
              self.rpcAvailable = false;
            }
          });
      } else {
        this.rpcAvailable = false;
      }
    },
    handleFile() {
      this.contractFile = this.$refs.contractFile.files[0];
    }
  }
};
</script>
<style>
.btn {
  color: #fff !important;
  text-transform: uppercase;
  text-decoration: none;
  background: #4caf50;
  padding: 20px;
  border-radius: 5px;
  display: inline-block;
  border: none;
  transition: all 0.4s ease 0s;
}
.btn:hover {
  background: #434343;
  letter-spacing: 1px;
  -webkit-box-shadow: 0 5px 40px -10px rgba(0, 0, 0, 0.57);
  -moz-box-shadow: 0 5px 40px -10px rgba(0, 0, 0, 0.57);
  box-shadow: 5px 40px -10px rgba(0, 0, 0, 0.57);
  transition: all 0.4s ease 0s;
}
.inputfile {
  width: 0.1px;
  height: 0.1px;
  opacity: 0;
  overflow: hidden;
  position: absolute;
  z-index: -1;
}

.inputfile + label {
  color: #fff !important;
  text-transform: uppercase;
  text-decoration: none;
  background: #4caf50;
  padding: 20px;
  border-radius: 5px;
  display: inline-block;
  border: none;
  transition: all 0.4s ease 0s;
  cursor: pointer;
}

.inputfile:focus + label,
.inputfile + label:hover {
  background: #434343;
  letter-spacing: 1px;
  -webkit-box-shadow: 0 5px 40px -10px rgba(0, 0, 0, 0.57);
  -moz-box-shadow: 0 5px 40px -10px rgba(0, 0, 0, 0.57);
  box-shadow: 5px 40px -10px rgba(0, 0, 0, 0.57);
  transition: all 0.4s ease 0s;
}

.contract {
  display: table;
}
</style>
